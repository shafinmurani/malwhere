import math
import numpy as np
import streamlit as st
import pyclamd
import hashlib
import pandas as pd
import os
import re
import pefile
import string
from collections import Counter

class MalwareScanner:
    def __init__(self):
        self.setup_scanner()

    def setup_scanner(self):
        try:
            self.clam = pyclamd.ClamdUnixSocket()
            self.clam.ping()
        except:
            try:
                self.clam = pyclamd.ClamdNetworkSocket()
                self.clam.ping()
            except:
                st.error("Could not connect to AV daemon")

    def calculate_entropy(self, data):
        """Calculate Shannon entropy of data"""
        if not data:
            return 0

        entropy = 0
        for x in range(256):
            p_x = data.count(x) / len(data)
            if p_x > 0:
                entropy += - p_x * math.log2(p_x)
        return entropy

    def extract_strings(self, data, min_length=4):
        """Extract ASCII and Unicode strings from binary data"""
        strings = []

        # ASCII strings
        ascii_chars = string.printable.encode('ascii')
        current_string = []

        for byte in data:
            if bytes([byte]) in ascii_chars:
                current_string.append(bytes([byte]))
            else:
                if len(current_string) >= min_length:
                    strings.append(b''.join(current_string).decode('ascii', errors='ignore'))
                current_string = []

        # Unicode strings (16-bit)
        unicode_chars = []
        for i in range(0, len(data)-1, 2):
            try:
                unicode_char = data[i:i+2].decode('utf-16')
                if unicode_char.isprintable():
                    unicode_chars.append(unicode_char)
                else:
                    if len(unicode_chars) >= min_length:
                        strings.append(''.join(unicode_chars))
                    unicode_chars = []
            except:
                continue

        return strings

    def analyze_strings(self, strings):
        """Analyze extracted strings for suspicious patterns"""
        features = {}

        # Suspicious string patterns
        suspicious_patterns = {
            'network': r'(http|ftp|smtp|tcp|udp|dns|ip|url|web|net|www)',
            'system_commands': r'(cmd\.exe|powershell|bash|sudo|chmod|chown)',
            'registry': r'(HKEY_|registry|reg\.exe)',
            'crypto': r'(bitcoin|wallet|encrypt|decrypt|ransom)',
            'injection': r'(inject|hook|patch|payload)',
            'obfuscation': r'(base64|rot13|xor|encrypt|decrypt)',
            'persistence': r'(startup|schedule|registry|service|task)',
            'evasion': r'(sleep|delay|timeout|bypass|avoid)',
        }

        # Count matches for each pattern
        for category, pattern in suspicious_patterns.items():
            matches = sum(1 for s in strings if re.search(pattern, s, re.I))
            features[f'suspicious_strings_{category}'] = matches

        # General string statistics
        features['total_strings'] = len(strings)
        features['avg_string_length'] = np.mean([len(s) for s in strings]) if strings else 0
        features['max_string_length'] = max([len(s) for s in strings]) if strings else 0

        # Character distribution analysis
        all_chars = ''.join(strings)
        char_counts = Counter(all_chars)
        features['unique_chars'] = len(char_counts)
        features['char_diversity'] = len(char_counts) / len(all_chars) if all_chars else 0

        return features

    def analyze_pe_file(self, filepath):
        """Analyze PE file structure and characteristics"""
        features = {}

        try:
            pe = pefile.PE(filepath)

            # Header analysis
            features['number_of_sections'] = len(pe.sections)
            features['timestamp'] = pe.FILE_HEADER.TimeDateStamp
            features['pointer_to_symbol_table'] = pe.FILE_HEADER.PointerToSymbolTable
            features['number_of_symbols'] = pe.FILE_HEADER.NumberOfSymbols

            # Section analysis
            section_features = {
                'executable_sections': 0,
                'writable_sections': 0,
                'suspicious_sections': 0,
                'total_entropy': 0
            }

            suspicious_section_names = {b'.text', b'.data', b'.rdata', b'.idata', b'.edata', b'.rsrc'}

            for section in pe.sections:
                # Section permissions
                if section.IMAGE_SCN_MEM_EXECUTE:
                    section_features['executable_sections'] += 1
                if section.IMAGE_SCN_MEM_WRITE:
                    section_features['writable_sections'] += 1

                # Section name analysis
                if section.Name.rstrip(b'\x00') not in suspicious_section_names:
                    section_features['suspicious_sections'] += 1

                # Section entropy
                section_features['total_entropy'] += self.calculate_entropy(section.get_data())

            features.update(section_features)
            features['avg_section_entropy'] = section_features['total_entropy'] / len(pe.sections)

            # Import analysis
            import_features = self.analyze_imports(pe)
            features.update(import_features)

            # Resources analysis
            if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
                features['has_resources'] = 1
                features['number_of_resources'] = sum(1 for _ in pe.DIRECTORY_ENTRY_RESOURCE.entries)
            else:
                features['has_resources'] = 0
                features['number_of_resources'] = 0

            # Additional characteristics
            features['has_debug'] = 1 if hasattr(pe, 'DIRECTORY_ENTRY_DEBUG') else 0
            features['has_tls'] = 1 if hasattr(pe, 'DIRECTORY_ENTRY_TLS') else 0
            features['has_load_config'] = 1 if hasattr(pe, 'DIRECTORY_ENTRY_LOAD_CONFIG') else 0

            pe.close()

        except Exception as e:
            # If PE analysis fails, set default values
            features.update({
                'number_of_sections': 0,
                'timestamp': 0,
                'pointer_to_symbol_table': 0,
                'number_of_symbols': 0,
                'executable_sections': 0,
                'writable_sections': 0,
                'suspicious_sections': 0,
                'avg_section_entropy': 0,
                'has_resources': 0,
                'number_of_resources': 0,
                'has_debug': 0,
                'has_tls': 0,
                'has_load_config': 0
            })

        return features

    def analyze_imports(self, pe):
        """Analyze imported functions and libraries"""
        features = {}

        suspicious_imports = {
            'process': ['CreateProcess', 'CreateRemoteThread', 'CreateThread', 'Process32', 'NtCreateProcess'],
            'injection': ['VirtualAlloc', 'VirtualProtect', 'WriteProcessMemory', 'ReadProcessMemory'],
            'network': ['URLDownload', 'InternetOpen', 'socket', 'connect', 'recv', 'send'],
            'crypto': ['CryptAcquireContext', 'CryptGenKey', 'CryptEncrypt', 'CryptDecrypt'],
            'registry': ['RegOpenKey', 'RegSetValue', 'RegCreateKey'],
            'file': ['CreateFile', 'WriteFile', 'ReadFile', 'DeleteFile'],
            'system': ['LoadLibrary', 'GetProcAddress', 'SystemParametersInfo'],
            'keyboard': ['SetWindowsHookEx', 'GetAsyncKeyState', 'GetKeyState']
        }

        # Initialize counters
        for category in suspicious_imports:
            features[f'suspicious_imports_{category}'] = 0

        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            total_imports = 0
            unique_dlls = set()

            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8', errors='ignore').lower()
                unique_dlls.add(dll_name)

                for imp in entry.imports:
                    total_imports += 1
                    if imp.name:
                        imp_name = imp.name.decode('utf-8', errors='ignore')

                        # Check for suspicious imports
                        for category, patterns in suspicious_imports.items():
                            if any(pattern.lower() in imp_name.lower() for pattern in patterns):
                                features[f'suspicious_imports_{category}'] += 1

            features['total_imports'] = total_imports
            features['unique_dlls'] = len(unique_dlls)
        else:
            features['total_imports'] = 0
            features['unique_dlls'] = 0

        return features

    def perform_heuristic_scan(self, filepath):
        """Enhanced heuristic scanning"""
        suspicious_patterns = [
            # Process manipulation
            rb'CreateRemoteThread',
            rb'VirtualAlloc',
            rb'WriteProcessMemory',
            rb'ReadProcessMemory',
            rb'CreateProcess',
            rb'ShellExecute',
            rb'WinExec',
            
            # Network activity
            rb'URLDownloadToFile',
            rb'InternetOpen',
            rb'socket',
            rb'connect',
            rb'recv',
            rb'send',
            
            # Registry manipulation
            rb'RegOpenKey',
            rb'RegSetValue',
            rb'RegCreateKey',
            
            # File operations
            rb'CreateFile',
            rb'WriteFile',
            rb'DeleteFile',
            
            # System manipulation
            rb'LoadLibrary',
            rb'GetProcAddress',
            
            # Keyboard/Mouse hooks
            rb'SetWindowsHookEx',
            rb'GetAsyncKeyState',
            
            # Common malware strings
            rb'cmd.exe',
            rb'powershell',
            rb'%APPDATA%',
            rb'%TEMP%',
            rb'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',
            
            # Cryptocurrency related
            rb'bitcoin',
            rb'wallet',
            rb'ransom',
            
            # Common encryption functions
            rb'CryptAcquireContext',
            rb'CryptGenKey',
            rb'CryptEncrypt'
        ]

        with open(filepath, 'rb') as file:
            file_data = file.read()

        suspicious_count = sum(1 for pattern in suspicious_patterns if re.search(pattern, file_data))

        return suspicious_count


        # Function to scan uploaded files
    def scan_files(self, uploaded_files):
        results = {}
        
        for f_data in uploaded_files:
            file_name = f_data.name
            file_path = os.path.join("C:\\Users\\shafi\\development\\malwhere\\uploaded_files", file_name)  # Define file path
            
            # Save the uploaded file temporarily
            with open(file_path, "wb") as f:
                f.write(f_data.getbuffer())
            
            # Scan file with ClamAV
            try:
                hash = self.hash_file(file_path)
                scan_result = self.clam.scan_file(file_path)
                
                if scan_result is None:
                    results[file_name] = ('OK', 'No virus found',hash)
                else:
                    results[file_name] = ('FOUND', scan_result[file_path][1],hash)  # Get signature
            except Exception as e:
                results[file_name] = ('ERROR', str(e))
            
            # Remove the file after scanning
            os.remove(file_path)
        
        return results

    def hash_file(self, filepath):
        """Calculate SHA256 hash of a file"""
        sha256_hash = hashlib.sha256()
        with open(filepath, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()